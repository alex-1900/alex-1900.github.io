---
layout: post
title: Entity, ValueObject 和 Service
date: 2021-06-08 06:39 +0000
authors: [Alex<omytty@126.com>]
categories: 开发
tags: domain
---

## Entity (Reference Object)
`Entity` 对象不通过属性定义，而是通过连续性和标识定义。Entity 具有生命周期，这期间它们的形式和属性可能发生根本改变，但必须保持一种内在的连续性，
（5 岁的儿童与 20 岁的成人可以是同一个人，这并不由包括名字在内的自身属性决定，而是具有一个外部的唯一标识）；
Entity 的职责、属性和关联必须由其标识来决定，而不依赖于其所具有的属性。总的来说，Entity 满足以下两个条件：

- Entity 在整个生命周期中具有连续性。
- Entity 之间的区别不由属性决定。

#### Entity 标识和编程语言层面的标识
面向对象编程语言为每个对象自动创建了标识（内存地址或引用），所以在本地运行环境中，每个对象都可以看作一个 Entity，但这种标识机制在其他应用领域中却没有意义。
所以 Entity 标识应该是一种具有意义的特殊属性，不应该把它交给语言的自动特性来处理，而且并不是所有对象都属于 Entity。

以银行为例，同一天，同一账户的两笔数额相同的存款，这两笔交易具有各自的标识（支票号码），所以每笔交易都是一个 Entity；另外，交易的金额属性可能是某种货币对象的实例，
但它们没有标识， 因为从业务上不需要区分它们，因此金额不属于 Entity.

#### Entity 对象建模
Entity 对象的基本职责是确保连续性，所以在建模时应该只添加那些用于识别、查找或匹配对象的属性和行为，并将其他属性和行为转移到与 Entity 关联的其他对象中。
Entity 往往通过协调其关联对象的操作来完成自己的职责。

## Value Object
`Value Object` 是用于描述领域的某个方面而本身没有概念标识的对象。对于此类对象，我们只关心它们是什么，而不关心它们是谁；
Value Object 模型元素应该能够表示出其属性的意义，并为它提供相关功能；Value Object 应该是简单的，无标识符的。

#### 区别对待 Entity 和 Value Object
一个系统中跟踪 Entity 标识很重要，但盲目的为对象添加唯一标识会增加系统复杂性和分析工作量，所以要根据业务区别对待系统中的模型，
仅在真正需要时才建立 Entity.

#### Value Object 的不变性
一般来说，Value Object 应该是不可改变的，这样可以确保共享和引用传递的安全性。如果属性值发生变化，则应该使用不同的 Value Object 进行替换，
而不是修改现有的 Value Object.

但有时出于性能考虑，也需要让 Value Object 成为可变的，主要考量以下因素：
- value 频繁改变
- 创建或删除 Value Object 开销很大
- value 的共享不会提高系统性能

总结为，如果一个 value 的实现是可变的，那么就不能共享它。原则是无论是否共享 Value Object，都应该尽可能的将它们设计成不可变的。

#### Denormalization (非规范化)
一个不可变的 Value Object 可以安全的被其他系统引用，但在某些场景下，引用可能会造成额外的 I/O 操作，例如数据库底层对处在不同页面的数据对象的引用；
在分布式系统中，对另一台机器上的 Value Object 的引用，也可能导致消息响应缓慢。诸如此类的问题，解决方案是在系统中的不同位置保存多个相同的
Value Object 副本，这种技术称为 `Denormalization`. 当访问时间比存储空间或维护的简单性更重要时，通常使用这种技术。

#### Value Object 之间没有双向关联
由于没有标识符，Value Object 之间的`双向关联`是没有意义的，因为我们不能说一个 Value Object 指向另一个 Value Object，只能说两个
Value Object 是等同的。因此在设计时，应该完全清除 Value Object 之间的双向关联。

## Service
